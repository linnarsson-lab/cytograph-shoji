<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>cytograph.enrichment.feature_selection_and_multilevel_enrichment API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cytograph.enrichment.feature_selection_and_multilevel_enrichment</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import List, Tuple

import numpy as np
import scipy.cluster.hierarchy as hc
import logging
from cytograph import requires, creates, Module
import cytograph as cg
import shoji


class FeatureSelectionAndMultilevelEnrichment(Module):
        def __init__(self, n_genes_per_group: int = 1, mask: List[str] = None, **kwargs) -&gt; None:
                &#34;&#34;&#34;
                Args:
                        n_genes                 Number of genes to select for each cluster group
                        mask                    Optional list indicating categories of genes that should not be selected
                &#34;&#34;&#34;
                super().__init__(**kwargs)
                self.n_genes_per_group = n_genes_per_group
                self.mask = mask if mask is not None else []

        def enrichment_by_clusters(self, ws: shoji.WorkspaceManager) -&gt; np.ndarray:
                &#34;&#34;&#34;
                Compute gene enrichment on already aggregated data, by cluster

                Args:
                        ws              The workspace
                
                Returns:
                        enrichment              A (n_clusters, n_genes) matrix of gene enrichment scores
                &#34;&#34;&#34;
                MeanExpression = self.requires[&#34;MeanExpression&#34;]

                n_clusters = ws.clusters.length
                x = ws[MeanExpression][...]
                totals = x.sum(axis=1)
                x_norm = (x.T / totals * np.median(totals)).T
                gene_sums = x_norm.sum(axis=0)
                enrichment = np.zeros_like(x_norm)
                for j in range(n_clusters):
                        enrichment[j, :] = (x_norm[j, :] + 0.01) / (((gene_sums - x_norm[j, :]) / (n_clusters - 1)) + 0.01)
                return enrichment

        def enrichment_by_cluster_groups(self, ws: shoji.WorkspaceManager, labels: np.ndarray) -&gt; np.ndarray:
                &#34;&#34;&#34;
                Compute gene enrichment for aggregate data, by groups of clusters

                Args:
                        ws              The workspace
                        labels  Labels (0, 1, ...) indicating the cluster groups

                Returns:
                        enrichment              A (n_groups, n_genes) matrix of gene enrichment scores
                &#34;&#34;&#34;
                MeanExpression = self.requires[&#34;MeanExpression&#34;]
                NCells = self.requires[&#34;NCells&#34;]

                n_clusters = labels.max() + 1
                n_cells = ws[NCells][...]
                data = (ws[MeanExpression][...].T * n_cells).T
                grouped = np.zeros((n_clusters, data.shape[1]))
                for j in range(n_clusters):
                        grouped[j, :] = data[labels == j, :].sum(axis=0) / n_cells[labels == j].sum()

                totals = grouped.sum(axis=1)
                x_norm = (grouped.T / totals * np.median(totals)).T
                gene_sums = x_norm.sum(axis=0)
                enrichment = np.zeros_like(x_norm)
                for j in range(n_clusters):
                        enrichment[j, :] = (x_norm[j, :] + 0.01) / (((gene_sums - x_norm[j, :]) / (n_clusters - 1)) + 0.01)
                
                return enrichment

        @requires(&#34;Species&#34;, &#34;string&#34;, ())
        @requires(&#34;Linkage&#34;, &#34;float64&#34;, None)
        @requires(&#34;MeanExpression&#34;, None, (&#34;clusters&#34;, &#34;genes&#34;))
        @requires(&#34;NCells&#34;, &#34;int64&#34;, (&#34;clusters&#34;,))
        @requires(&#34;Gene&#34;, &#34;string&#34;, (&#34;genes&#34;,))
        @creates(&#34;SelectedFeatures&#34;, &#34;bool&#34;, (&#34;genes&#34;,), indices=True)  # indices=True means that the return value is a vector of indices that should be automatically converted to a bool vector
        @creates(&#34;Enrichment&#34;, &#34;float32&#34;, (&#34;clusters&#34;, &#34;genes&#34;))
        def fit(self, ws: shoji.WorkspaceManager, save: bool = False) -&gt; Tuple[np.ndarray, np.ndarray]:
                &#34;&#34;&#34;
                Select genes at multiple levels in a hierarchy of clusters

                Args:
                        ws                              The shoji workspace containing aggregate data
                        save                    If true, save the result as tensor SelectedFeatures (default: false)

                Returns:
                        SelectedFeatures        Indices of the selected genes
                        Enrichment                      Enrichment scores
                
                Remarks:
                        The number of genes selected will depend on the number of clusters as follows. The dendrogram is
                        cut at n = 2, 4, 8, ... (for n &lt;= n_clusters // 2) clusters and the most enriched n_genes are selected for each cluster
                        (without replacement). Finally, the most enriched gene in each cluster is selected (without replacement) and added to the list.

                        Note that this module requires aggregate tensors (MeanExpression, NCells)
                &#34;&#34;&#34;
                # Create symbolic names for the required tensors, which might be renamed by the user
                Species = self.requires[&#34;Species&#34;]
                Linkage = self.requires[&#34;Linkage&#34;]
                Gene = self.requires[&#34;Gene&#34;]

                logging.info(&#34; FeatureSelectionAndMultilevelEnrichment: Selecting features at 2, 4, 8, ... cluster levels&#34;)
                n_clusters = ws.clusters.length

                species = cg.Species(ws[Species][:])
                mask_genes = species.mask(ws, self.mask)

                n = 2
                selected: List[int] = []

                # Select from the dendrogram
                while n &lt;= n_clusters // 2:
                        labels = hc.cut_tree(ws[Linkage][...], n_clusters=n).T[0]
                        enr = self.enrichment_by_cluster_groups(ws, labels)
                        for j in range(n):
                                top = np.argsort(-enr[j, :])
                                n_selected = 0
                                for t in top:
                                        if t not in selected and not mask_genes[t]:
                                                n_selected += 1
                                                selected.append(t)
                                                if n_selected == self.n_genes_per_group:
                                                        break
                        n *= 2

                logging.info(&#34; FeatureSelectionAndMultilevelEnrichment: Selecting features and calculating enrichment at cluster leaves&#34;)
                # Select from the leaves
                enr = self.enrichment_by_clusters(ws)
                for j in range(n_clusters):
                        top = np.argsort(-enr[j, :])
                        n_selected = 0
                        for t in top:
                                if t not in selected and mask_genes[t]:
                                        n_selected += 1
                                        selected.append(t)
                                        if n_selected == self.n_genes_per_group:
                                                break

                logging.info(f&#34; FeatureSelectionAndMultilevelEnrichment: Selected {len(selected)} features&#34;)
                return selected, enr</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cytograph.enrichment.feature_selection_and_multilevel_enrichment.FeatureSelectionAndMultilevelEnrichment"><code class="flex name class">
<span>class <span class="ident">FeatureSelectionAndMultilevelEnrichment</span></span>
<span>(</span><span>n_genes_per_group: int = 1, mask: List[str] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<p>n_genes
Number of genes to select for each cluster group
mask
Optional list indicating categories of genes that should not be selected</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FeatureSelectionAndMultilevelEnrichment(Module):
        def __init__(self, n_genes_per_group: int = 1, mask: List[str] = None, **kwargs) -&gt; None:
                &#34;&#34;&#34;
                Args:
                        n_genes                 Number of genes to select for each cluster group
                        mask                    Optional list indicating categories of genes that should not be selected
                &#34;&#34;&#34;
                super().__init__(**kwargs)
                self.n_genes_per_group = n_genes_per_group
                self.mask = mask if mask is not None else []

        def enrichment_by_clusters(self, ws: shoji.WorkspaceManager) -&gt; np.ndarray:
                &#34;&#34;&#34;
                Compute gene enrichment on already aggregated data, by cluster

                Args:
                        ws              The workspace
                
                Returns:
                        enrichment              A (n_clusters, n_genes) matrix of gene enrichment scores
                &#34;&#34;&#34;
                MeanExpression = self.requires[&#34;MeanExpression&#34;]

                n_clusters = ws.clusters.length
                x = ws[MeanExpression][...]
                totals = x.sum(axis=1)
                x_norm = (x.T / totals * np.median(totals)).T
                gene_sums = x_norm.sum(axis=0)
                enrichment = np.zeros_like(x_norm)
                for j in range(n_clusters):
                        enrichment[j, :] = (x_norm[j, :] + 0.01) / (((gene_sums - x_norm[j, :]) / (n_clusters - 1)) + 0.01)
                return enrichment

        def enrichment_by_cluster_groups(self, ws: shoji.WorkspaceManager, labels: np.ndarray) -&gt; np.ndarray:
                &#34;&#34;&#34;
                Compute gene enrichment for aggregate data, by groups of clusters

                Args:
                        ws              The workspace
                        labels  Labels (0, 1, ...) indicating the cluster groups

                Returns:
                        enrichment              A (n_groups, n_genes) matrix of gene enrichment scores
                &#34;&#34;&#34;
                MeanExpression = self.requires[&#34;MeanExpression&#34;]
                NCells = self.requires[&#34;NCells&#34;]

                n_clusters = labels.max() + 1
                n_cells = ws[NCells][...]
                data = (ws[MeanExpression][...].T * n_cells).T
                grouped = np.zeros((n_clusters, data.shape[1]))
                for j in range(n_clusters):
                        grouped[j, :] = data[labels == j, :].sum(axis=0) / n_cells[labels == j].sum()

                totals = grouped.sum(axis=1)
                x_norm = (grouped.T / totals * np.median(totals)).T
                gene_sums = x_norm.sum(axis=0)
                enrichment = np.zeros_like(x_norm)
                for j in range(n_clusters):
                        enrichment[j, :] = (x_norm[j, :] + 0.01) / (((gene_sums - x_norm[j, :]) / (n_clusters - 1)) + 0.01)
                
                return enrichment

        @requires(&#34;Species&#34;, &#34;string&#34;, ())
        @requires(&#34;Linkage&#34;, &#34;float64&#34;, None)
        @requires(&#34;MeanExpression&#34;, None, (&#34;clusters&#34;, &#34;genes&#34;))
        @requires(&#34;NCells&#34;, &#34;int64&#34;, (&#34;clusters&#34;,))
        @requires(&#34;Gene&#34;, &#34;string&#34;, (&#34;genes&#34;,))
        @creates(&#34;SelectedFeatures&#34;, &#34;bool&#34;, (&#34;genes&#34;,), indices=True)  # indices=True means that the return value is a vector of indices that should be automatically converted to a bool vector
        @creates(&#34;Enrichment&#34;, &#34;float32&#34;, (&#34;clusters&#34;, &#34;genes&#34;))
        def fit(self, ws: shoji.WorkspaceManager, save: bool = False) -&gt; Tuple[np.ndarray, np.ndarray]:
                &#34;&#34;&#34;
                Select genes at multiple levels in a hierarchy of clusters

                Args:
                        ws                              The shoji workspace containing aggregate data
                        save                    If true, save the result as tensor SelectedFeatures (default: false)

                Returns:
                        SelectedFeatures        Indices of the selected genes
                        Enrichment                      Enrichment scores
                
                Remarks:
                        The number of genes selected will depend on the number of clusters as follows. The dendrogram is
                        cut at n = 2, 4, 8, ... (for n &lt;= n_clusters // 2) clusters and the most enriched n_genes are selected for each cluster
                        (without replacement). Finally, the most enriched gene in each cluster is selected (without replacement) and added to the list.

                        Note that this module requires aggregate tensors (MeanExpression, NCells)
                &#34;&#34;&#34;
                # Create symbolic names for the required tensors, which might be renamed by the user
                Species = self.requires[&#34;Species&#34;]
                Linkage = self.requires[&#34;Linkage&#34;]
                Gene = self.requires[&#34;Gene&#34;]

                logging.info(&#34; FeatureSelectionAndMultilevelEnrichment: Selecting features at 2, 4, 8, ... cluster levels&#34;)
                n_clusters = ws.clusters.length

                species = cg.Species(ws[Species][:])
                mask_genes = species.mask(ws, self.mask)

                n = 2
                selected: List[int] = []

                # Select from the dendrogram
                while n &lt;= n_clusters // 2:
                        labels = hc.cut_tree(ws[Linkage][...], n_clusters=n).T[0]
                        enr = self.enrichment_by_cluster_groups(ws, labels)
                        for j in range(n):
                                top = np.argsort(-enr[j, :])
                                n_selected = 0
                                for t in top:
                                        if t not in selected and not mask_genes[t]:
                                                n_selected += 1
                                                selected.append(t)
                                                if n_selected == self.n_genes_per_group:
                                                        break
                        n *= 2

                logging.info(&#34; FeatureSelectionAndMultilevelEnrichment: Selecting features and calculating enrichment at cluster leaves&#34;)
                # Select from the leaves
                enr = self.enrichment_by_clusters(ws)
                for j in range(n_clusters):
                        top = np.argsort(-enr[j, :])
                        n_selected = 0
                        for t in top:
                                if t not in selected and mask_genes[t]:
                                        n_selected += 1
                                        selected.append(t)
                                        if n_selected == self.n_genes_per_group:
                                                break

                logging.info(f&#34; FeatureSelectionAndMultilevelEnrichment: Selected {len(selected)} features&#34;)
                return selected, enr</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cytograph.module.Module" href="../module.html#cytograph.module.Module">Module</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cytograph.enrichment.feature_selection_and_multilevel_enrichment.FeatureSelectionAndMultilevelEnrichment.enrichment_by_cluster_groups"><code class="name flex">
<span>def <span class="ident">enrichment_by_cluster_groups</span></span>(<span>self, ws: shoji.workspace.WorkspaceManager, labels: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Compute gene enrichment for aggregate data, by groups of clusters</p>
<h2 id="args">Args</h2>
<p>ws
The workspace
labels
Labels (0, 1, &hellip;) indicating the cluster groups</p>
<h2 id="returns">Returns</h2>
<p>enrichment
A (n_groups, n_genes) matrix of gene enrichment scores</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enrichment_by_cluster_groups(self, ws: shoji.WorkspaceManager, labels: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Compute gene enrichment for aggregate data, by groups of clusters

        Args:
                ws              The workspace
                labels  Labels (0, 1, ...) indicating the cluster groups

        Returns:
                enrichment              A (n_groups, n_genes) matrix of gene enrichment scores
        &#34;&#34;&#34;
        MeanExpression = self.requires[&#34;MeanExpression&#34;]
        NCells = self.requires[&#34;NCells&#34;]

        n_clusters = labels.max() + 1
        n_cells = ws[NCells][...]
        data = (ws[MeanExpression][...].T * n_cells).T
        grouped = np.zeros((n_clusters, data.shape[1]))
        for j in range(n_clusters):
                grouped[j, :] = data[labels == j, :].sum(axis=0) / n_cells[labels == j].sum()

        totals = grouped.sum(axis=1)
        x_norm = (grouped.T / totals * np.median(totals)).T
        gene_sums = x_norm.sum(axis=0)
        enrichment = np.zeros_like(x_norm)
        for j in range(n_clusters):
                enrichment[j, :] = (x_norm[j, :] + 0.01) / (((gene_sums - x_norm[j, :]) / (n_clusters - 1)) + 0.01)
        
        return enrichment</code></pre>
</details>
</dd>
<dt id="cytograph.enrichment.feature_selection_and_multilevel_enrichment.FeatureSelectionAndMultilevelEnrichment.enrichment_by_clusters"><code class="name flex">
<span>def <span class="ident">enrichment_by_clusters</span></span>(<span>self, ws: shoji.workspace.WorkspaceManager) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Compute gene enrichment on already aggregated data, by cluster</p>
<h2 id="args">Args</h2>
<p>ws
The workspace</p>
<h2 id="returns">Returns</h2>
<p>enrichment
A (n_clusters, n_genes) matrix of gene enrichment scores</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enrichment_by_clusters(self, ws: shoji.WorkspaceManager) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Compute gene enrichment on already aggregated data, by cluster

        Args:
                ws              The workspace
        
        Returns:
                enrichment              A (n_clusters, n_genes) matrix of gene enrichment scores
        &#34;&#34;&#34;
        MeanExpression = self.requires[&#34;MeanExpression&#34;]

        n_clusters = ws.clusters.length
        x = ws[MeanExpression][...]
        totals = x.sum(axis=1)
        x_norm = (x.T / totals * np.median(totals)).T
        gene_sums = x_norm.sum(axis=0)
        enrichment = np.zeros_like(x_norm)
        for j in range(n_clusters):
                enrichment[j, :] = (x_norm[j, :] + 0.01) / (((gene_sums - x_norm[j, :]) / (n_clusters - 1)) + 0.01)
        return enrichment</code></pre>
</details>
</dd>
<dt id="cytograph.enrichment.feature_selection_and_multilevel_enrichment.FeatureSelectionAndMultilevelEnrichment.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, ws: shoji.workspace.WorkspaceManager, save: bool = False) ‑> Tuple[numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Select genes at multiple levels in a hierarchy of clusters</p>
<h2 id="args">Args</h2>
<p>ws
The shoji workspace containing aggregate data
save
If true, save the result as tensor SelectedFeatures (default: false)</p>
<h2 id="returns">Returns</h2>
<p>SelectedFeatures
Indices of the selected genes
Enrichment
Enrichment scores</p>
<h2 id="remarks">Remarks</h2>
<p>The number of genes selected will depend on the number of clusters as follows. The dendrogram is
cut at n = 2, 4, 8, &hellip; (for n &lt;= n_clusters // 2) clusters and the most enriched n_genes are selected for each cluster
(without replacement). Finally, the most enriched gene in each cluster is selected (without replacement) and added to the list.</p>
<p>Note that this module requires aggregate tensors (MeanExpression, NCells)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@requires(&#34;Species&#34;, &#34;string&#34;, ())
@requires(&#34;Linkage&#34;, &#34;float64&#34;, None)
@requires(&#34;MeanExpression&#34;, None, (&#34;clusters&#34;, &#34;genes&#34;))
@requires(&#34;NCells&#34;, &#34;int64&#34;, (&#34;clusters&#34;,))
@requires(&#34;Gene&#34;, &#34;string&#34;, (&#34;genes&#34;,))
@creates(&#34;SelectedFeatures&#34;, &#34;bool&#34;, (&#34;genes&#34;,), indices=True)  # indices=True means that the return value is a vector of indices that should be automatically converted to a bool vector
@creates(&#34;Enrichment&#34;, &#34;float32&#34;, (&#34;clusters&#34;, &#34;genes&#34;))
def fit(self, ws: shoji.WorkspaceManager, save: bool = False) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;
        Select genes at multiple levels in a hierarchy of clusters

        Args:
                ws                              The shoji workspace containing aggregate data
                save                    If true, save the result as tensor SelectedFeatures (default: false)

        Returns:
                SelectedFeatures        Indices of the selected genes
                Enrichment                      Enrichment scores
        
        Remarks:
                The number of genes selected will depend on the number of clusters as follows. The dendrogram is
                cut at n = 2, 4, 8, ... (for n &lt;= n_clusters // 2) clusters and the most enriched n_genes are selected for each cluster
                (without replacement). Finally, the most enriched gene in each cluster is selected (without replacement) and added to the list.

                Note that this module requires aggregate tensors (MeanExpression, NCells)
        &#34;&#34;&#34;
        # Create symbolic names for the required tensors, which might be renamed by the user
        Species = self.requires[&#34;Species&#34;]
        Linkage = self.requires[&#34;Linkage&#34;]
        Gene = self.requires[&#34;Gene&#34;]

        logging.info(&#34; FeatureSelectionAndMultilevelEnrichment: Selecting features at 2, 4, 8, ... cluster levels&#34;)
        n_clusters = ws.clusters.length

        species = cg.Species(ws[Species][:])
        mask_genes = species.mask(ws, self.mask)

        n = 2
        selected: List[int] = []

        # Select from the dendrogram
        while n &lt;= n_clusters // 2:
                labels = hc.cut_tree(ws[Linkage][...], n_clusters=n).T[0]
                enr = self.enrichment_by_cluster_groups(ws, labels)
                for j in range(n):
                        top = np.argsort(-enr[j, :])
                        n_selected = 0
                        for t in top:
                                if t not in selected and not mask_genes[t]:
                                        n_selected += 1
                                        selected.append(t)
                                        if n_selected == self.n_genes_per_group:
                                                break
                n *= 2

        logging.info(&#34; FeatureSelectionAndMultilevelEnrichment: Selecting features and calculating enrichment at cluster leaves&#34;)
        # Select from the leaves
        enr = self.enrichment_by_clusters(ws)
        for j in range(n_clusters):
                top = np.argsort(-enr[j, :])
                n_selected = 0
                for t in top:
                        if t not in selected and mask_genes[t]:
                                n_selected += 1
                                selected.append(t)
                                if n_selected == self.n_genes_per_group:
                                        break

        logging.info(f&#34; FeatureSelectionAndMultilevelEnrichment: Selected {len(selected)} features&#34;)
        return selected, enr</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cytograph.enrichment" href="index.html">cytograph.enrichment</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cytograph.enrichment.feature_selection_and_multilevel_enrichment.FeatureSelectionAndMultilevelEnrichment" href="#cytograph.enrichment.feature_selection_and_multilevel_enrichment.FeatureSelectionAndMultilevelEnrichment">FeatureSelectionAndMultilevelEnrichment</a></code></h4>
<ul class="">
<li><code><a title="cytograph.enrichment.feature_selection_and_multilevel_enrichment.FeatureSelectionAndMultilevelEnrichment.enrichment_by_cluster_groups" href="#cytograph.enrichment.feature_selection_and_multilevel_enrichment.FeatureSelectionAndMultilevelEnrichment.enrichment_by_cluster_groups">enrichment_by_cluster_groups</a></code></li>
<li><code><a title="cytograph.enrichment.feature_selection_and_multilevel_enrichment.FeatureSelectionAndMultilevelEnrichment.enrichment_by_clusters" href="#cytograph.enrichment.feature_selection_and_multilevel_enrichment.FeatureSelectionAndMultilevelEnrichment.enrichment_by_clusters">enrichment_by_clusters</a></code></li>
<li><code><a title="cytograph.enrichment.feature_selection_and_multilevel_enrichment.FeatureSelectionAndMultilevelEnrichment.fit" href="#cytograph.enrichment.feature_selection_and_multilevel_enrichment.FeatureSelectionAndMultilevelEnrichment.fit">fit</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>