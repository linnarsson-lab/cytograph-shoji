<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>cytograph.pipeline.collect_cells API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cytograph.pipeline.collect_cells</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from cytograph.pipeline.punchcards import Punchcard
from typing import List
import shoji
import numpy as np
from .config import Config
import logging
import cytograph as cg
from cytograph import Algorithm
import sys
from sklearn.preprocessing import LabelEncoder


class CollectCells(Algorithm):
        &#34;&#34;&#34;
        Collect tensors from the source workspaces (e.g. samples)
        &#34;&#34;&#34;
        def __init__(self, tensors: List[str], expand_scalars: bool = True, renumber_tensors: List[str] = None, **kwargs) -&gt; None:
                &#34;&#34;&#34;
                Args:
                        tensors                         List of tensors to be collected (must exist and have same dims and dtype in all samples)
                        expand_scalars          If true, scalars are converted to vectors (repeating the scalar value)
                        renumber_tensors        List of tensors that should be renumbered to stay unique while combining sources (e.g. &#34;Clusters&#34;)

                Remarks:
                        Tensors can be renamed on the fly using the A-&gt;B syntax, e.g. &#34;SampleName-&gt;SampleID&#34;
                &#34;&#34;&#34;
                super().__init__(**kwargs)

                self.tensors = tensors
                self.expand_scalars = expand_scalars
                self.renumber_tensors = renumber_tensors if renumber_tensors is not None else []

        def fit(self, ws: shoji.WorkspaceManager, save: bool = False) -&gt; None:
                &#34;&#34;&#34;
                Collect cells from a list of workspaces (defined in config.sources) into this workspace

                Args:
                        ws                              shoji workspace
                &#34;&#34;&#34;
                db = shoji.connect()
                config = Config.load()
                punchcard = config.punchcard
                assert punchcard is not None
                build_ws = config.workspaces.build
                assert build_ws is not None

                for ix, source in enumerate(punchcard.sources):
                        assert build_ws is not None
                        if source != punchcard.name and source in build_ws:
                                source_ws = build_ws[source]
                        elif source in db[config.workspaces.samples_workspace_name]:
                                source_ws = db[config.workspaces.samples_workspace_name][source]
                        else:
                                logging.error(f&#34;Source {source} not found!&#34;)
                                sys.exit(1)
                        onlyif = punchcard.sources_onlyif[ix]
                        if onlyif is not None:
                                logging.info(f&#34; CollectCells: Collecting tensors from &#39;{source}&#39; where &#39;{onlyif}&#39;&#34;)
                                conditions = eval(onlyif, {&#34;ws&#34;: source_ws, &#34;np&#34;: np, &#34;shoji&#34;: shoji, &#34;cg&#34;: cg})
                                if not isinstance(conditions, shoji.Filter):
                                        raise ValueError(f&#34;Conditions in &#39;onlyif&#39; must evaluate to a shoji.Filter, but &#39;{onlyif}&#39; evaluated to &#39;{type(conditions)}&#39;&#34;)
                                view = source_ws[conditions]
                                indices = view.filters[&#34;cells&#34;].get_rows(source_ws)
                        else:
                                logging.info(f&#34; CollectCells: Collecting tensors from &#39;{source}&#39;&#34;)
                                view = source_ws[:]
                                indices = np.arange(source_ws.cells.length)
                        if punchcard.with_annotation is not None:
                                logging.info(f&#34; CollectCells: Keeping only cells that have auto-annotation &#39;{punchcard.with_annotation}&#39;&#34;)
                                if &#34;AnnotationPosterior&#34; not in source_ws:
                                        raise ValueError(f&#34;Punchcard uses &#39;with_annotation&#39; but source &#39;{source}&#39; lacks auto-annotation&#34;)
                                pp = source_ws.AnnotationPosterior[:, source_ws.AnnotationName == punchcard.with_annotation]
                                keep_clusters = source_ws.ClusterID[pp &gt; 0.95]
                                labels = source_ws.Clusters[:]
                                aa_indices = np.array([], dtype=&#34;uint32&#34;)
                                for cluster in keep_clusters:
                                        aa_indices = np.union1d(aa_indices, np.where(labels == cluster)[0])
                                indices = np.intersect1d(indices, aa_indices)
                                logging.info(f&#34; CollectCells: Keeping {indices.shape[0]} cells from {keep_clusters.shape[0]} clusters with &#39;{punchcard.with_annotation}&#39;&#34;)
                        batch_size = 5_000
                        for start in range(0, indices.shape[0], batch_size):
                                d = {}
                                for tensor_spec in self.tensors:
                                        if &#34;-&gt;&#34; in tensor_spec:
                                                tensor, new_name = tensor_spec.split(&#34;-&gt;&#34;)
                                        else:
                                                tensor, new_name = tensor_spec, tensor_spec
                                        if tensor not in source_ws:
                                                logging.error(f&#34;Tensor &#39;{tensor}&#39; missing in source workspace &#39;{source}&#34;)
                                                sys.exit(1)
                                        t = source_ws[tensor]
                                        if new_name in self.renumber_tensors and t.rank != 1:
                                                logging.error(f&#34;Cannot renumber tensor &#39;{tensor}&#39; because rank is not 1&#34;)
                                                sys.exit(1)
                                        if t.rank &gt; 0:
                                                if t.dims[0] != &#34;cells&#34;:
                                                        logging.error(f&#34;Cannot collect tensor &#39;{tensor}&#39; because first dimension is not &#39;cells&#39;&#34;)
                                                        sys.exit(1)
                                                if ix == 0 and start == 0:
                                                        ws[new_name] = shoji.Tensor(t.dtype, t.dims)
                                                d[new_name] = source_ws[tensor][indices[start: start + batch_size]]
                                        elif t.rank == 0:
                                                if self.expand_scalars:
                                                        if ix == 0 and start == 0:
                                                                ws[new_name] = shoji.Tensor(t.dtype, (&#34;cells&#34;,))
                                                        d[new_name] = np.full(min(indices.shape[0] - start, batch_size), t[:], dtype=t.numpy_dtype())
                                                elif ix == 0 and start == 0:
                                                        ws[new_name] = shoji.Tensor(t.dtype, t.dims, inits=t[:])
                                ws.cells.append(d)
                                start += batch_size

                for tensor in self.renumber_tensors:
                        offset = 0  # Offset of cluster IDs
                        ix = 0  # Index of cells
                        for source in punchcard.sources:
                                logging.info(f&#34; CollectCells: Renumbering &#39;{tensor}&#39; from &#39;{source}&#39; with offset={offset}&#34;)
                                if source != punchcard.name and source in build_ws:
                                        source_ws = build_ws[source]
                                elif source in db[config.workspaces.samples_workspace_name]:
                                        source_ws = db[config.workspaces.samples_workspace_name][source]
                                if onlyif is not None:
                                        conditions = eval(onlyif, {&#34;ws&#34;: source_ws, &#34;np&#34;: np, &#34;shoji&#34;: shoji, &#34;cg&#34;: cg})
                                        view = source_ws[conditions]
                                else:
                                        view = source_ws[:]
                                vals = LabelEncoder().fit_transform(view[tensor])
                                ws[tensor][ix:ix + vals.shape[0]] = vals + offset
                                offset = offset + max(vals) + 1
                                ix += vals.shape[0]

                ws.cells = shoji.Dimension(shape=ws.cells.length)  # Fix the length of the cells dimension
                logging.info(f&#34; CollectCells: Collected {ws.cells.length} cells&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cytograph.pipeline.collect_cells.CollectCells"><code class="flex name class">
<span>class <span class="ident">CollectCells</span></span>
<span>(</span><span>tensors: List[str], expand_scalars: bool = True, renumber_tensors: List[str] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Collect tensors from the source workspaces (e.g. samples)</p>
<h2 id="args">Args</h2>
<p>tensors
List of tensors to be collected (must exist and have same dims and dtype in all samples)
expand_scalars
If true, scalars are converted to vectors (repeating the scalar value)
renumber_tensors
List of tensors that should be renumbered to stay unique while combining sources (e.g. "Clusters")</p>
<h2 id="remarks">Remarks</h2>
<p>Tensors can be renamed on the fly using the A-&gt;B syntax, e.g. "SampleName-&gt;SampleID"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CollectCells(Algorithm):
        &#34;&#34;&#34;
        Collect tensors from the source workspaces (e.g. samples)
        &#34;&#34;&#34;
        def __init__(self, tensors: List[str], expand_scalars: bool = True, renumber_tensors: List[str] = None, **kwargs) -&gt; None:
                &#34;&#34;&#34;
                Args:
                        tensors                         List of tensors to be collected (must exist and have same dims and dtype in all samples)
                        expand_scalars          If true, scalars are converted to vectors (repeating the scalar value)
                        renumber_tensors        List of tensors that should be renumbered to stay unique while combining sources (e.g. &#34;Clusters&#34;)

                Remarks:
                        Tensors can be renamed on the fly using the A-&gt;B syntax, e.g. &#34;SampleName-&gt;SampleID&#34;
                &#34;&#34;&#34;
                super().__init__(**kwargs)

                self.tensors = tensors
                self.expand_scalars = expand_scalars
                self.renumber_tensors = renumber_tensors if renumber_tensors is not None else []

        def fit(self, ws: shoji.WorkspaceManager, save: bool = False) -&gt; None:
                &#34;&#34;&#34;
                Collect cells from a list of workspaces (defined in config.sources) into this workspace

                Args:
                        ws                              shoji workspace
                &#34;&#34;&#34;
                db = shoji.connect()
                config = Config.load()
                punchcard = config.punchcard
                assert punchcard is not None
                build_ws = config.workspaces.build
                assert build_ws is not None

                for ix, source in enumerate(punchcard.sources):
                        assert build_ws is not None
                        if source != punchcard.name and source in build_ws:
                                source_ws = build_ws[source]
                        elif source in db[config.workspaces.samples_workspace_name]:
                                source_ws = db[config.workspaces.samples_workspace_name][source]
                        else:
                                logging.error(f&#34;Source {source} not found!&#34;)
                                sys.exit(1)
                        onlyif = punchcard.sources_onlyif[ix]
                        if onlyif is not None:
                                logging.info(f&#34; CollectCells: Collecting tensors from &#39;{source}&#39; where &#39;{onlyif}&#39;&#34;)
                                conditions = eval(onlyif, {&#34;ws&#34;: source_ws, &#34;np&#34;: np, &#34;shoji&#34;: shoji, &#34;cg&#34;: cg})
                                if not isinstance(conditions, shoji.Filter):
                                        raise ValueError(f&#34;Conditions in &#39;onlyif&#39; must evaluate to a shoji.Filter, but &#39;{onlyif}&#39; evaluated to &#39;{type(conditions)}&#39;&#34;)
                                view = source_ws[conditions]
                                indices = view.filters[&#34;cells&#34;].get_rows(source_ws)
                        else:
                                logging.info(f&#34; CollectCells: Collecting tensors from &#39;{source}&#39;&#34;)
                                view = source_ws[:]
                                indices = np.arange(source_ws.cells.length)
                        if punchcard.with_annotation is not None:
                                logging.info(f&#34; CollectCells: Keeping only cells that have auto-annotation &#39;{punchcard.with_annotation}&#39;&#34;)
                                if &#34;AnnotationPosterior&#34; not in source_ws:
                                        raise ValueError(f&#34;Punchcard uses &#39;with_annotation&#39; but source &#39;{source}&#39; lacks auto-annotation&#34;)
                                pp = source_ws.AnnotationPosterior[:, source_ws.AnnotationName == punchcard.with_annotation]
                                keep_clusters = source_ws.ClusterID[pp &gt; 0.95]
                                labels = source_ws.Clusters[:]
                                aa_indices = np.array([], dtype=&#34;uint32&#34;)
                                for cluster in keep_clusters:
                                        aa_indices = np.union1d(aa_indices, np.where(labels == cluster)[0])
                                indices = np.intersect1d(indices, aa_indices)
                                logging.info(f&#34; CollectCells: Keeping {indices.shape[0]} cells from {keep_clusters.shape[0]} clusters with &#39;{punchcard.with_annotation}&#39;&#34;)
                        batch_size = 5_000
                        for start in range(0, indices.shape[0], batch_size):
                                d = {}
                                for tensor_spec in self.tensors:
                                        if &#34;-&gt;&#34; in tensor_spec:
                                                tensor, new_name = tensor_spec.split(&#34;-&gt;&#34;)
                                        else:
                                                tensor, new_name = tensor_spec, tensor_spec
                                        if tensor not in source_ws:
                                                logging.error(f&#34;Tensor &#39;{tensor}&#39; missing in source workspace &#39;{source}&#34;)
                                                sys.exit(1)
                                        t = source_ws[tensor]
                                        if new_name in self.renumber_tensors and t.rank != 1:
                                                logging.error(f&#34;Cannot renumber tensor &#39;{tensor}&#39; because rank is not 1&#34;)
                                                sys.exit(1)
                                        if t.rank &gt; 0:
                                                if t.dims[0] != &#34;cells&#34;:
                                                        logging.error(f&#34;Cannot collect tensor &#39;{tensor}&#39; because first dimension is not &#39;cells&#39;&#34;)
                                                        sys.exit(1)
                                                if ix == 0 and start == 0:
                                                        ws[new_name] = shoji.Tensor(t.dtype, t.dims)
                                                d[new_name] = source_ws[tensor][indices[start: start + batch_size]]
                                        elif t.rank == 0:
                                                if self.expand_scalars:
                                                        if ix == 0 and start == 0:
                                                                ws[new_name] = shoji.Tensor(t.dtype, (&#34;cells&#34;,))
                                                        d[new_name] = np.full(min(indices.shape[0] - start, batch_size), t[:], dtype=t.numpy_dtype())
                                                elif ix == 0 and start == 0:
                                                        ws[new_name] = shoji.Tensor(t.dtype, t.dims, inits=t[:])
                                ws.cells.append(d)
                                start += batch_size

                for tensor in self.renumber_tensors:
                        offset = 0  # Offset of cluster IDs
                        ix = 0  # Index of cells
                        for source in punchcard.sources:
                                logging.info(f&#34; CollectCells: Renumbering &#39;{tensor}&#39; from &#39;{source}&#39; with offset={offset}&#34;)
                                if source != punchcard.name and source in build_ws:
                                        source_ws = build_ws[source]
                                elif source in db[config.workspaces.samples_workspace_name]:
                                        source_ws = db[config.workspaces.samples_workspace_name][source]
                                if onlyif is not None:
                                        conditions = eval(onlyif, {&#34;ws&#34;: source_ws, &#34;np&#34;: np, &#34;shoji&#34;: shoji, &#34;cg&#34;: cg})
                                        view = source_ws[conditions]
                                else:
                                        view = source_ws[:]
                                vals = LabelEncoder().fit_transform(view[tensor])
                                ws[tensor][ix:ix + vals.shape[0]] = vals + offset
                                offset = offset + max(vals) + 1
                                ix += vals.shape[0]

                ws.cells = shoji.Dimension(shape=ws.cells.length)  # Fix the length of the cells dimension
                logging.info(f&#34; CollectCells: Collected {ws.cells.length} cells&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cytograph.algorithm.Algorithm" href="../algorithm.html#cytograph.algorithm.Algorithm">Algorithm</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cytograph.pipeline.collect_cells.CollectCells.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, ws: shoji.workspace.WorkspaceManager, save: bool = False) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Collect cells from a list of workspaces (defined in config.sources) into this workspace</p>
<h2 id="args">Args</h2>
<p>ws
shoji workspace</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self, ws: shoji.WorkspaceManager, save: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Collect cells from a list of workspaces (defined in config.sources) into this workspace

        Args:
                ws                              shoji workspace
        &#34;&#34;&#34;
        db = shoji.connect()
        config = Config.load()
        punchcard = config.punchcard
        assert punchcard is not None
        build_ws = config.workspaces.build
        assert build_ws is not None

        for ix, source in enumerate(punchcard.sources):
                assert build_ws is not None
                if source != punchcard.name and source in build_ws:
                        source_ws = build_ws[source]
                elif source in db[config.workspaces.samples_workspace_name]:
                        source_ws = db[config.workspaces.samples_workspace_name][source]
                else:
                        logging.error(f&#34;Source {source} not found!&#34;)
                        sys.exit(1)
                onlyif = punchcard.sources_onlyif[ix]
                if onlyif is not None:
                        logging.info(f&#34; CollectCells: Collecting tensors from &#39;{source}&#39; where &#39;{onlyif}&#39;&#34;)
                        conditions = eval(onlyif, {&#34;ws&#34;: source_ws, &#34;np&#34;: np, &#34;shoji&#34;: shoji, &#34;cg&#34;: cg})
                        if not isinstance(conditions, shoji.Filter):
                                raise ValueError(f&#34;Conditions in &#39;onlyif&#39; must evaluate to a shoji.Filter, but &#39;{onlyif}&#39; evaluated to &#39;{type(conditions)}&#39;&#34;)
                        view = source_ws[conditions]
                        indices = view.filters[&#34;cells&#34;].get_rows(source_ws)
                else:
                        logging.info(f&#34; CollectCells: Collecting tensors from &#39;{source}&#39;&#34;)
                        view = source_ws[:]
                        indices = np.arange(source_ws.cells.length)
                if punchcard.with_annotation is not None:
                        logging.info(f&#34; CollectCells: Keeping only cells that have auto-annotation &#39;{punchcard.with_annotation}&#39;&#34;)
                        if &#34;AnnotationPosterior&#34; not in source_ws:
                                raise ValueError(f&#34;Punchcard uses &#39;with_annotation&#39; but source &#39;{source}&#39; lacks auto-annotation&#34;)
                        pp = source_ws.AnnotationPosterior[:, source_ws.AnnotationName == punchcard.with_annotation]
                        keep_clusters = source_ws.ClusterID[pp &gt; 0.95]
                        labels = source_ws.Clusters[:]
                        aa_indices = np.array([], dtype=&#34;uint32&#34;)
                        for cluster in keep_clusters:
                                aa_indices = np.union1d(aa_indices, np.where(labels == cluster)[0])
                        indices = np.intersect1d(indices, aa_indices)
                        logging.info(f&#34; CollectCells: Keeping {indices.shape[0]} cells from {keep_clusters.shape[0]} clusters with &#39;{punchcard.with_annotation}&#39;&#34;)
                batch_size = 5_000
                for start in range(0, indices.shape[0], batch_size):
                        d = {}
                        for tensor_spec in self.tensors:
                                if &#34;-&gt;&#34; in tensor_spec:
                                        tensor, new_name = tensor_spec.split(&#34;-&gt;&#34;)
                                else:
                                        tensor, new_name = tensor_spec, tensor_spec
                                if tensor not in source_ws:
                                        logging.error(f&#34;Tensor &#39;{tensor}&#39; missing in source workspace &#39;{source}&#34;)
                                        sys.exit(1)
                                t = source_ws[tensor]
                                if new_name in self.renumber_tensors and t.rank != 1:
                                        logging.error(f&#34;Cannot renumber tensor &#39;{tensor}&#39; because rank is not 1&#34;)
                                        sys.exit(1)
                                if t.rank &gt; 0:
                                        if t.dims[0] != &#34;cells&#34;:
                                                logging.error(f&#34;Cannot collect tensor &#39;{tensor}&#39; because first dimension is not &#39;cells&#39;&#34;)
                                                sys.exit(1)
                                        if ix == 0 and start == 0:
                                                ws[new_name] = shoji.Tensor(t.dtype, t.dims)
                                        d[new_name] = source_ws[tensor][indices[start: start + batch_size]]
                                elif t.rank == 0:
                                        if self.expand_scalars:
                                                if ix == 0 and start == 0:
                                                        ws[new_name] = shoji.Tensor(t.dtype, (&#34;cells&#34;,))
                                                d[new_name] = np.full(min(indices.shape[0] - start, batch_size), t[:], dtype=t.numpy_dtype())
                                        elif ix == 0 and start == 0:
                                                ws[new_name] = shoji.Tensor(t.dtype, t.dims, inits=t[:])
                        ws.cells.append(d)
                        start += batch_size

        for tensor in self.renumber_tensors:
                offset = 0  # Offset of cluster IDs
                ix = 0  # Index of cells
                for source in punchcard.sources:
                        logging.info(f&#34; CollectCells: Renumbering &#39;{tensor}&#39; from &#39;{source}&#39; with offset={offset}&#34;)
                        if source != punchcard.name and source in build_ws:
                                source_ws = build_ws[source]
                        elif source in db[config.workspaces.samples_workspace_name]:
                                source_ws = db[config.workspaces.samples_workspace_name][source]
                        if onlyif is not None:
                                conditions = eval(onlyif, {&#34;ws&#34;: source_ws, &#34;np&#34;: np, &#34;shoji&#34;: shoji, &#34;cg&#34;: cg})
                                view = source_ws[conditions]
                        else:
                                view = source_ws[:]
                        vals = LabelEncoder().fit_transform(view[tensor])
                        ws[tensor][ix:ix + vals.shape[0]] = vals + offset
                        offset = offset + max(vals) + 1
                        ix += vals.shape[0]

        ws.cells = shoji.Dimension(shape=ws.cells.length)  # Fix the length of the cells dimension
        logging.info(f&#34; CollectCells: Collected {ws.cells.length} cells&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cytograph.pipeline" href="index.html">cytograph.pipeline</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cytograph.pipeline.collect_cells.CollectCells" href="#cytograph.pipeline.collect_cells.CollectCells">CollectCells</a></code></h4>
<ul class="">
<li><code><a title="cytograph.pipeline.collect_cells.CollectCells.fit" href="#cytograph.pipeline.collect_cells.CollectCells.fit">fit</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>